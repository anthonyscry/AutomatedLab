---
phase: 31-advanced-reporting
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - Public/Get-LabResourceReport.ps1
  - Private/Get-LabVMMetrics.ps1
  - Tests/LabResourceReport.Tests.ps1
autonomous: true
requirements:
  - RPT-02

must_haves:
  truths:
    - "Operator can generate resource utilization reports showing disk, memory, and CPU trends"
    - "Reports aggregate resource data across all VMs in the lab"
    - "Resource trends can be grouped by time period (hourly, daily, weekly)"
    - "Reports identify resource bottlenecks and usage patterns"
    - "Historical resource data is collected from analytics events and current VM metrics"
  artifacts:
    - path: "Public/Get-LabResourceReport.ps1"
      provides: "Public API for generating resource utilization reports"
      exports: ["Get-LabResourceReport"]
      min_lines: 90
    - path: "Private/Format-LabResourceReport.ps1"
      provides: "Core resource report formatting logic"
      min_lines: 150
    - path: "Private/Get-LabResourceTrendCore.ps1"
      provides: "Resource trend aggregation over time periods"
      min_lines: 100
  key_links:
    - from: "Get-LabResourceReport.ps1"
      to: "Get-LabVMMetrics.ps1"
      via: "Collects current VM resource metrics"
      pattern: "Get-LabVMMetrics"
    - from: "Get-LabResourceReport.ps1"
      to: "Get-LabAnalytics.ps1"
      via: "Reads analytics events for historical resource data"
      pattern: "Get-LabAnalytics"
    - from: "Get-LabResourceTrendCore.ps1"
      to: "Get-LabUsageTrendsCore.ps1"
      via: "Reuses time-based aggregation patterns"
      pattern: "Period|Group"
    - from: "Format-LabResourceReport.ps1"
      to: "Format-LabComplianceReport.ps1"
      via: "Reuses HTML formatting patterns from compliance reports"
      pattern: "HTML|format"
---

<objective>
Create resource utilization report generation that aggregates disk, memory, and CPU usage data across all lab VMs with time-based trend analysis and bottleneck identification.

Purpose: Enable operators to understand resource consumption patterns in their lab environment, identify capacity constraints before they become problems, and make informed decisions about resource allocation and VM sizing.

Output: Get-LabResourceReport public API, Get-LabResourceTrendCore aggregation function, Format-LabResourceReport formatting function, and unit tests for resource trend calculations.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-dashboard-enrichment/29-02-PLAN.md
@.planning/phases/30-lab-analytics/30-02-PLAN.md
@.planning/phases/31-advanced-reporting/31-01-PLAN.md

# Existing patterns from codebase (for reference, not to copy)
Private/Get-LabVMMetrics.ps1 (Phase 29) - Shows VM metrics collection for CPU, memory, disk
Private/Get-LabUsageTrendsCore.ps1 (Phase 30) - Shows time-based aggregation patterns
Private/Format-LabComplianceReport.ps1 (Plan 31-01) - Shows multi-format report generation
Public/Get-LabUsageTrends.ps1 (Phase 30) - Shows public API pattern with defaults
</context>

<tasks>

<task type="auto">
  <name>Create Get-LabResourceTrendCore aggregation function</name>
  <files>Private/Get-LabResourceTrendCore.ps1</files>
  <action>
Create Private/Get-LabResourceTrendCore.ps1 with resource trend aggregation logic:

```powershell
function Get-LabResourceTrendCore {
    <#
    .SYNOPSIS
        Aggregates VM resource metrics into time-based trends.

    .DESCRIPTION
        Get-LabResourceTrendCore processes current VM metrics and historical
        analytics events to produce resource utilization trends grouped by
        time period. Calculates average and peak values for CPU, memory,
        and disk usage across all VMs.

    .PARAMETER VMMetrics
        Current VM metrics array to process.

    .PARAMETER AnalyticsEvents
        Historical analytics events for trend context (optional).

    .PARAMETER Period
        Grouping period: 'Hour', 'Day', 'Week'.

    .OUTPUTS
        [pscustomobject[]] with PeriodStart, PeriodEnd, AvgCPU, AvgMemoryGB,
        AvgDiskGB, PeakCPU, PeakMemoryGB, PeakDiskGB, VMCount properties.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject[]])]
    param(
        [Parameter(Mandatory)]
        [pscustomobject[]]$VMMetrics,

        [pscustomobject[]]$AnalyticsEvents = @(),

        [Parameter(Mandatory)]
        [ValidateSet('Hour', 'Day', 'Week')]
        [string]$Period
    )

    if ($VMMetrics.Count -eq 0) {
        Write-Warning "No VM metrics provided for trend analysis"
        return @()
    }

    $now = Get-Date
    $grouped = @{}

    foreach ($vm in $VMMetrics) {
        $timestamp = if ($vm.CollectedAt) {
            [DateTime]::Parse($vm.CollectedAt)
        } else {
            $now
        }

        $periodKey = switch ($Period) {
            'Hour' {
                "$($timestamp.ToString('yyyy-MM-dd HH')):00"
            }
            'Day' {
                $timestamp.ToString('yyyy-MM-dd')
            }
            'Week' {
                $culture = [System.Globalization.CultureInfo]::InvariantCulture
                $calendar = $culture.Calendar
                $weekRule = $calendar.GetWeekOfYear($timestamp, [System.Globalization.CalendarWeekRule]::FirstDay, [DayOfWeek]::Monday)
                "$($timestamp.Year)-W$($weekRule.ToString('00'))"
            }
        }

        if (-not $grouped.ContainsKey($periodKey)) {
            $grouped[$periodKey] = @{
                PeriodStart  = $timestamp
                PeriodEnd    = $timestamp
                CPUSamples   = [System.Collections.Generic.List[double]]::new()
                MemorySamples = [System.Collections.Generic.List[double]]::new()
                DiskSamples   = [System.Collections.Generic.List[double]]::new()
            }
        }

        $group = $grouped[$periodKey]

        if ($timestamp -lt $group.PeriodStart) {
            $group.PeriodStart = $timestamp
        }
        if ($timestamp -gt $group.PeriodEnd) {
            $group.PeriodEnd = $timestamp
        }

        if ($vm.CPUPercent -ge 0) {
            $group.CPUSamples.Add([double]$vm.CPUPercent)
        }
        if ($vm.MemoryGB -ge 0) {
            $group.MemorySamples.Add([double]$vm.MemoryGB)
        }
        if ($vm.DiskGB -ge 0) {
            $group.DiskSamples.Add([double]$vm.DiskGB)
        }
    }

    $results = [System.Collections.Generic.List[pscustomobject]]::new()

    foreach ($key in $grouped.Keys | Sort-Object) {
        $group = $grouped[$key]

        $avgCPU = if ($group.CPUSamples.Count -gt 0) {
            [math]::Round(($group.CPUSamples | Measure-Object -Average).Average, 1)
        } else { 0.0 }

        $avgMemory = if ($group.MemorySamples.Count -gt 0) {
            [math]::Round(($group.MemorySamples | Measure-Object -Average).Average, 2)
        } else { 0.0 }

        $avgDisk = if ($group.DiskSamples.Count -gt 0) {
            [math]::Round(($group.DiskSamples | Measure-Object -Average).Average, 2)
        } else { 0.0 }

        $peakCPU = if ($group.CPUSamples.Count -gt 0) {
            [math]::Round(($group.CPUSamples | Measure-Object -Maximum).Maximum, 1)
        } else { 0.0 }

        $peakMemory = if ($group.MemorySamples.Count -gt 0) {
            [math]::Round(($group.MemorySamples | Measure-Object -Maximum).Maximum, 2)
        } else { 0.0 }

        $peakDisk = if ($group.DiskSamples.Count -gt 0) {
            [math]::Round(($group.DiskSamples | Measure-Object -Maximum).Maximum, 2)
        } else { 0.0 }

        $result = [pscustomobject]@{
            Period        = $key
            PeriodStart   = $group.PeriodStart
            PeriodEnd     = $group.PeriodEnd
            AvgCPU        = $avgCPU
            AvgMemoryGB   = $avgMemory
            AvgDiskGB     = $avgDisk
            PeakCPU       = $peakCPU
            PeakMemoryGB  = $peakMemory
            PeakDiskGB    = $peakDisk
            VMCount       = $group.CPUSamples.Count
        }

        $results.Add($result)
    }

    return @($results)
}
```

This function follows the time-based aggregation pattern from Get-LabUsageTrendsCore (Phase 30). It groups VM metrics by the specified period, calculates average and peak values for CPU/memory/disk, and returns structured trend data. The function handles missing or invalid metric values gracefully with conditional checks.
  </action>
  <verify>Get-LabResourceTrendCore -VMMetrics @($metrics) -Period Day returns trend data with AvgCPU, AvgMemoryGB, AvgDiskGB properties</verify>
  <done>Get-LabResourceTrendCore function exists and aggregates resource metrics by time period</done>
</task>

<task type="auto">
  <name>Create Format-LabResourceReport formatting function</name>
  <files>Private/Format-LabResourceReport.ps1</files>
  <action>
Create Private/Format-LabResourceReport.ps1 with multi-format report generation:

```powershell
function Format-LabResourceReport {
    <#
    .SYNOPSIS
        Formats resource utilization data into console, HTML, CSV, or JSON output.

    .DESCRIPTION
        Format-LabResourceReport takes processed resource data and generates
        formatted output in the specified format. Supports console tables,
        HTML reports with visual indicators, CSV exports, and JSON exports.
        Includes bottleneck identification and usage pattern analysis.

    .PARAMETER ResourceData
        Per-VM resource metrics with VMName, CPUPercent, MemoryGB, DiskGB fields.

    .PARAMETER TrendData
        Aggregated trend data with time-based averages and peaks (optional).

    .PARAMETER Format
        Output format: 'Console', 'Html', 'Csv', 'Json'.

    .PARAMETER LabName
        Name of the lab for the report header.

    .PARAMETER OutputPath
        Path to save the report file (required for Html, Csv, Json formats).

    .PARAMETER Thresholds
        Hashtable with warning thresholds for CPU, Memory, Disk (optional).

    .OUTPUTS
        For Console: Formatted string output
        For Html/Csv/Json: Path to saved file
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [pscustomobject[]]$ResourceData,

        [pscustomobject[]]$TrendData = @(),

        [Parameter(Mandatory)]
        [ValidateSet('Console', 'Html', 'Csv', 'Json')]
        [string]$Format,

        [string]$LabName = 'AutomatedLab',

        [string]$OutputPath,

        [hashtable]$Thresholds = @{}
    )

    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'

    $defaultThresholds = @{
        CPUWarning    = 70
        CPUCritical   = 90
        MemoryWarning = 80
        MemoryCritical = 95
        DiskWarning   = 80
        DiskCritical  = 95
    }

    foreach ($key in $defaultThresholds.Keys) {
        if (-not $Thresholds.ContainsKey($key)) {
            $Thresholds[$key] = $defaultThresholds[$key]
        }
    }

    $totalVMs = $ResourceData.Count

    $avgCPU = if ($totalVMs -gt 0) {
        [math]::Round(($ResourceData | Measure-Object -Property CPUPercent -Average).Average, 1)
    } else { 0.0 }

    $avgMemory = if ($totalVMs -gt 0) {
        [math]::Round(($ResourceData | Measure-Object -Property MemoryGB -Average).Average, 2)
    } else { 0.0 }

    $avgDisk = if ($totalVMs -gt 0) {
        [math]::Round(($ResourceData | Measure-Object -Property DiskGB -Average).Average, 2)
    } else { 0.0 }

    $highCPUVMs = @($ResourceData | Where-Object { $_.CPUPercent -ge $Thresholds.CPUWarning })
    $highMemoryVMs = @($ResourceData | Where-Object { $_.MemoryGB -ge $Thresholds.MemoryWarning })
    $highDiskVMs = @($ResourceData | Where-Object { $_.DiskGB -ge $Thresholds.DiskWarning })

    switch ($Format) {
        'Console' {
            $output = [System.Text.StringBuilder]::new()
            [void]$output.AppendLine('')
            [void]$output.AppendLine('  +--------------------------------------------------------------+')
            [void]$output.AppendLine('  |                  RESOURCE UTILIZATION REPORT               |')
            [void]$output.AppendLine('  +--------------------------------------------------------------+')
            [void]$output.AppendLine("  Lab:           $LabName")
            [void]$output.AppendLine("  Generated:     $timestamp")
            [void]$output.AppendLine('')
            [void]$output.AppendLine('  SUMMARY')
            [void]$output.AppendLine('  -------')
            [void]$output.AppendLine("  Total VMs:         $totalVMs")
            [void]$output.AppendLine("  Avg CPU:           $avgCPU% (High: $($highCPUVMs.Count))")
            [void]$output.AppendLine("  Avg Memory:        $avgMemory GB (High: $($highMemoryVMs.Count))")
            [void]$output.AppendLine("  Avg Disk:          $avgDisk GB (High: $($highDiskVMs.Count))")

            if ($highCPUVMs.Count -gt 0 -or $highMemoryVMs.Count -gt 0 -or $highDiskVMs.Count -gt 0) {
                [void]$output.AppendLine('')
                [void]$output.AppendLine('  BOTTLENECKS DETECTED')
                [void]$output.AppendLine('  --------------------')

                if ($highCPUVMs.Count -gt 0) {
                    [void]$output.AppendLine("  High CPU (> $($Thresholds.CPUWarning)%): $($highCPUVMs.VMName -join ', ')")
                }
                if ($highMemoryVMs.Count -gt 0) {
                    [void]$output.AppendLine("  High Memory (> $($Thresholds.MemoryWarning)GB): $($highMemoryVMs.VMName -join ', ')")
                }
                if ($highDiskVMs.Count -gt 0) {
                    [void]$output.AppendLine("  High Disk (> $($Thresholds.DiskWarning)%): $($highDiskVMs.VMName -join ', ')")
                }
            }

            [void]$output.AppendLine('')
            [void]$output.AppendLine('  VM DETAILS')
            [void]$output.AppendLine('  -----------')
            [void]$output.AppendLine('  VM Name      CPU %     Memory GB   Disk %     Status')
            [void]$output.AppendLine('  -------      ------    ----------   -------    ------')

            foreach ($vm in $ResourceData) {
                $status = switch ($vm.CPUPercent) {
                    { $_ -ge $Thresholds.CPUCritical } { 'CRIT' }
                    { $_ -ge $Thresholds.CPUWarning } { 'WARN' }
                    default { 'OK' }
                }

                if ($vm.DiskGB -ge $Thresholds.DiskCritical) {
                    $status = 'CRIT'
                } elseif ($vm.DiskGB -ge $Thresholds.DiskWarning) {
                    $status = 'WARN'
                }

                [void]$output.AppendLine(("  {0,-12} {1,-8} {2,-10} {3,-8} {4}" -f
                    $vm.VMName,
                    "$($vm.CPUPercent)%",
                    "$($vm.MemoryGB)",
                    "$($vm.DiskGB)%",
                    $status))
            }

            Write-Host $output.ToString()
        }

        'Html' {
            if (-not $OutputPath) {
                Write-Error "OutputPath is required for Html format"
                return
            }

            $vmRows = ($ResourceData | ForEach-Object {
                $statusClass = switch ($_.CPUPercent) {
                    { $_ -ge $Thresholds.CPUCritical } { 'critical' }
                    { $_ -ge $Thresholds.CPUWarning } { 'warning' }
                    default { 'ok' }
                }

                if ($_.DiskGB -ge $Thresholds.DiskCritical) {
                    $statusClass = 'critical'
                } elseif ($_.DiskGB -ge $Thresholds.DiskWarning) {
                    $statusClass = 'warning'
                }

                ("        <tr class=`"$statusClass`"><td>$($_.VMName)</td><td>$($_.CPUPercent)%</td><td>$($_.MemoryGB) GB</td><td>$($_.DiskGB)%</td><td>$statusClass.ToUpper()</td></tr>")
            }) -join "`n"

            $bottlenecks = @()
            if ($highCPUVMs.Count -gt 0) {
                $bottlenecks += "<li>High CPU: $($highCPUVMs.VMName -join ', ')</li>"
            }
            if ($highMemoryVMs.Count -gt 0) {
                $bottlenecks += "<li>High Memory: $($highMemoryVMs.VMName -join ', ')</li>"
            }
            if ($highDiskVMs.Count -gt 0) {
                $bottlenecks += "<li>High Disk: $($highDiskVMs.VMName -join ', ')</li>"
            }
            $bottleneckHtml = if ($bottlenecks.Count -gt 0) {
                "<ul>$($bottlenecks -join '')</ul>"
            } else {
                "<p>No bottlenecks detected</p>"
            }

            $html = @"
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Resource Report - $LabName</title>
<style>
  body { font-family: 'Segoe UI', Tahoma, sans-serif; margin: 40px; background: #1e1e2e; color: #cdd6f4; }
  h1 { color: #89b4fa; border-bottom: 2px solid #45475a; padding-bottom: 10px; }
  .meta { color: #a6adc8; margin-bottom: 20px; }
  .meta span { display: inline-block; margin-right: 30px; }
  .summary { background: #313244; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
  .summary h2 { margin-top: 0; color: #89b4fa; }
  .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
  .stat-box { background: #45475a; padding: 15px; border-radius: 6px; text-align: center; }
  .stat-value { font-size: 2em; font-weight: bold; color: #f38ba8; }
  .stat-label { color: #a6adc8; font-size: 0.9em; }
  .bottlenecks { background: #313244; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
  .bottlenecks h2 { margin-top: 0; color: #fab387; }
  .bottlenecks ul { list-style: none; padding: 0; }
  .bottlenecks li { padding: 5px 0; }
  table { border-collapse: collapse; width: 100%; margin-top: 20px; }
  th { background: #313244; color: #cba6f7; padding: 10px 15px; text-align: left; }
  td { padding: 8px 15px; border-bottom: 1px solid #45475a; }
  tr.ok td:last-child { color: #a6e3a1; font-weight: bold; }
  tr.warning td:last-child { color: #f9e2af; font-weight: bold; }
  tr.critical td:last-child { color: #f38ba8; font-weight: bold; }
  .footer { margin-top: 30px; color: #6c7086; font-size: 0.85em; }
</style>
</head>
<body>
  <h1>Resource Utilization Report</h1>
  <div class="meta">
    <span>Lab: <strong>$LabName</strong></span>
    <span>Generated: <strong>$timestamp</strong></span>
  </div>

  <div class="summary">
    <h2>Resource Summary</h2>
    <div class="stat-grid">
      <div class="stat-box">
        <div class="stat-value">$avgCPU%</div>
        <div class="stat-label">Avg CPU</div>
      </div>
      <div class="stat-box">
        <div class="stat-value">$avgMemory GB</div>
        <div class="stat-label">Avg Memory</div>
      </div>
      <div class="stat-box">
        <div class="stat-value">$avgDisk%</div>
        <div class="stat-label">Avg Disk</div>
      </div>
    </div>
  </div>

  <div class="bottlenecks">
    <h2>Bottlenecks</h2>
    $bottleneckHtml
  </div>

  <table>
    <thead>
      <tr><th>VM Name</th><th>CPU</th><th>Memory</th><th>Disk</th><th>Status</th></tr>
    </thead>
    <tbody>
$vmRows
    </tbody>
  </table>

  <div class="footer">Generated by AutomatedLab on $timestamp</div>
</body>
</html>
"@

            $parentDir = Split-Path -Parent $OutputPath
            if (-not [string]::IsNullOrWhiteSpace($parentDir) -and -not (Test-Path $parentDir)) {
                $null = New-Item -Path $parentDir -ItemType Directory -Force
            }

            [System.IO.File]::WriteAllText($OutputPath, $html, [System.Text.Encoding]::UTF8)
            $resolvedPath = (Resolve-Path $OutputPath).Path
            Write-Host "`n  Resource report saved: $resolvedPath" -ForegroundColor Cyan
            return $resolvedPath
        }

        'Csv' {
            if (-not $OutputPath) {
                Write-Error "OutputPath is required for Csv format"
                return
            }

            $ResourceData | Select-Object VMName, CPUPercent, MemoryGB, DiskGB | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8
            $resolvedPath = (Resolve-Path $OutputPath).Path
            Write-Host "`n  Resource report saved: $resolvedPath" -ForegroundColor Cyan
            return $resolvedPath
        }

        'Json' {
            if (-not $OutputPath) {
                Write-Error "OutputPath is required for Json format"
                return
            }

            $reportData = [pscustomobject]@{
                LabName            = $LabName
                GeneratedAt        = $timestamp
                Summary            = [pscustomobject]@{
                    TotalVMs        = $totalVMs
                    AvgCPU          = $avgCPU
                    AvgMemoryGB     = $avgMemory
                    AvgDiskGB       = $avgDisk
                    HighCPUVMs      = $highCPUVMs.VMName
                    HighMemoryVMs   = $highMemoryVMs.VMName
                    HighDiskVMs     = $highDiskVMs.VMName
                }
                VMs                = $ResourceData
                Trends             = $TrendData
            }

            $reportData | ConvertTo-Json -Depth 5 | Set-Content -Path $OutputPath -Encoding UTF8
            $resolvedPath = (Resolve-Path $OutputPath).Path
            Write-Host "`n  Resource report saved: $resolvedPath" -ForegroundColor Cyan
            return $resolvedPath
        }
    }
}
```

This function follows the HTML formatting pattern from Format-LabComplianceReport (Plan 31-01) and New-LabDeploymentReport.ps1. It provides bottleneck identification based on configurable thresholds, visual status indicators (OK/WARN/CRIT), and supports multiple output formats. The HTML output uses consistent styling with compliance reports.
  </action>
  <verify>Format-LabResourceReport -Format Console -ResourceData @($metrics) displays console output with summary statistics and bottleneck identification</verify>
  <done>Format-LabResourceReport function exists and generates reports in all four formats with bottleneck detection</done>
</task>

<task type="auto">
  <name>Create Get-LabResourceReport public API</name>
  <files>Public/Get-LabResourceReport.ps1</files>
  <action>
Create Public/Get-LabResourceReport.ps1 for generating resource reports:

```powershell
function Get-LabResourceReport {
    <#
    .SYNOPSIS
        Generates a resource utilization report for the lab.

    .DESCRIPTION
        Get-LabResourceReport collects current VM metrics and generates
        a comprehensive resource utilization report. Reports include summary
        statistics, bottleneck identification, and per-VM resource details.
        Supports multiple output formats including console, HTML, CSV, and JSON.
        Can optionally include trend analysis over time periods.

    .PARAMETER Format
        Output format: 'Console', 'Html', 'Csv', 'Json'. Defaults to 'Console'.

    .PARAMETER LabName
        Name of the lab for the report header. Defaults to reading from
        $GlobalLabConfig.Lab.LabName.

    .PARAMETER OutputPath
        Path to save the report file. Required for Html, Csv, Json formats.
        For Console format, this parameter is ignored.

    .PARAMETER IncludeTrends
        Include trend analysis in the report (JSON format only).

    .PARAMETER TrendPeriod
        Time period for trend grouping: 'Hour', 'Day', 'Week'. Defaults to 'Day'.

    .PARAMETER Thresholds
        Hashtable with custom warning thresholds for CPU, Memory, Disk.

    .EXAMPLE
        Get-LabResourceReport
        Displays a console resource report with default settings.

    .EXAMPLE
        Get-LabResourceReport -Format Html -OutputPath 'resources.html'
        Generates an HTML resource report.

    .EXAMPLE
        Get-LabResourceReport -IncludeTrends -TrendPeriod Week -OutputPath 'resources.json'
        Generates a JSON report with weekly trend analysis.

    .OUTPUTS
        For Console format: Console output (no return value)
        For Html/Csv/Json format: Path to saved report file
    #>
    [CmdletBinding()]
    param(
        [ValidateSet('Console', 'Html', 'Csv', 'Json')]
        [string]$Format = 'Console',

        [string]$LabName,

        [string]$OutputPath,

        [switch]$IncludeTrends,

        [ValidateSet('Hour', 'Day', 'Week')]
        [string]$TrendPeriod = 'Day',

        [hashtable]$Thresholds
    )

    if (-not $PSBoundParameters.ContainsKey('LabName')) {
        $LabName = if (Test-Path variable:GlobalLabConfig -and $GlobalLabConfig.ContainsKey('Lab') -and $GlobalLabConfig.Lab.ContainsKey('LabName')) {
            $GlobalLabConfig.Lab.LabName
        } else {
            'AutomatedLab'
        }
    }

    try {
        $vmMetrics = Get-LabVMMetrics
    }
    catch {
        Write-Warning "Failed to collect VM metrics: $($_.Exception.Message)"
        $vmMetrics = @()
    }

    if ($vmMetrics.Count -eq 0) {
        Write-Warning "No VM metrics found. Ensure lab VMs are running."
        return $null
    }

    $trendData = @()
    if ($IncludeTrends -and $Format -eq 'Json') {
        try {
            $analyticsEvents = Get-LabAnalytics
            $trendData = Get-LabResourceTrendCore -VMMetrics $vmMetrics -AnalyticsEvents $analyticsEvents -Period $TrendPeriod
        }
        catch {
            Write-Warning "Failed to generate trend data: $($_.Exception.Message)"
        }
    }

    $formatParams = @{
        ResourceData = $vmMetrics
        Format       = $Format
        LabName      = $LabName
    }

    if ($Format -ne 'Console') {
        if ([string]::IsNullOrWhiteSpace($OutputPath)) {
            $reportsConfig = Get-LabReportsConfig
            $dateStamp = Get-Date -Format 'yyyyMMdd-HHmmss'
            $extension = switch ($Format) {
                'Html' { '.html' }
                'Csv'  { '.csv' }
                'Json' { '.json' }
            }
            $reportDir = Join-Path $reportsConfig.ComplianceReportPath '..' 'resources'
            $OutputPath = Join-Path $reportDir "resources-$dateStamp$extension"
        }
        $formatParams.OutputPath = $OutputPath
    }

    if ($PSBoundParameters.ContainsKey('Thresholds')) {
        $formatParams.Thresholds = $Thresholds
    }

    if ($IncludeTrends -and $trendData.Count -gt 0) {
        $formatParams.TrendData = $trendData
    }

    return Format-LabResourceReport @formatParams
}
```

This function follows the public API pattern from Get-LabComplianceReport (Plan 31-01) and Get-LabUsageTrends (Phase 30). It collects current VM metrics via Get-LabVMMetrics, optionally generates trend data via Get-LabResourceTrendCore, delegates formatting to Format-LabResourceReport, and auto-generates output filenames when not specified.
  </action>
  <verify>Get-LabResourceReport -Format Console displays console output with resource summary and bottleneck identification</verify>
  <done>Get-LabResourceReport public API exists with support for all output formats and optional trend analysis</done>
</task>

<task type="auto">
  <name>Add Get-LabResourceReport to module exports</name>
  <files>SimpleLab.psm1, SimpleLab.psd1</files>
  <action>
Update both SimpleLab.psm1 and SimpleLab.psd1 to export Get-LabResourceReport.

In SimpleLab.psm1 (around line 44), add 'Get-LabResourceReport' to the Export-ModuleMember array. Maintain alphabetical ordering within the exports list.

In SimpleLab.psd1, add 'Get-LabResourceReport' to the FunctionsToExport array in the same position.

This follows the established pattern for public API functions from Phases 29-31.
  </action>
  <verify>Get-Command Get-LabResourceReport -Module SimpleLab returns command info</verify>
  <done>Get-LabResourceReport is exported from the SimpleLab module</done>
</task>

<task type="auto">
  <name>Create unit tests for resource report generation</name>
  <files>Tests/LabResourceReport.Tests.ps1</files>
  <action>
Create Tests/LabResourceReport.Tests.ps1 with comprehensive test coverage:

```powershell
BeforeAll {
    $ModulePath = Join-Path (Join-Path (Join-Path $PSScriptRoot '..') SimpleLab) 'SimpleLab.psm1'
    Import-Module $ModulePath -Force

    . (Join-Path (Join-Path $PSScriptRoot '..') Private) 'Get-LabResourceTrendCore.ps1'
    . (Join-Path (Join-Path $PSScriptRoot '..') Private) 'Format-LabResourceReport.ps1'

    $GlobalLabConfig = @{
        Lab = @{
            LabName = 'TestLab'
        }
    }
}

Describe 'Get-LabResourceTrendCore' {
    It 'Aggregates VM metrics by time period' {
        $testMetrics = @(
            [pscustomobject]@{ VMName = 'vm1'; CPUPercent = 50; MemoryGB = 4; DiskGB = 30; CollectedAt = '2026-02-21T10:00:00' }
            [pscustomobject]@{ VMName = 'vm2'; CPUPercent = 70; MemoryGB = 8; DiskGB = 50; CollectedAt = '2026-02-21T10:00:00' }
        )

        $result = Get-LabResourceTrendCore -VMMetrics $testMetrics -Period Day

        $result | Should -HaveCount 1
        $result[0].AvgCPU | Should -Be 60.0
        $result[0].AvgMemoryGB | Should -Be 6.0
        $result[0].AvgDiskGB | Should -Be 40.0
        $result[0].VMCount | Should -Be 2
    }

    It 'Calculates peak values correctly' {
        $testMetrics = @(
            [pscustomobject]@{ VMName = 'vm1'; CPUPercent = 30; MemoryGB = 4; DiskGB = 20; CollectedAt = '2026-02-21T10:00:00' }
            [pscustomobject]@{ VMName = 'vm2'; CPUPercent = 90; MemoryGB = 16; DiskGB = 80; CollectedAt = '2026-02-21T10:00:00' }
        )

        $result = Get-LabResourceTrendCore -VMMetrics $testMetrics -Period Day

        $result[0].PeakCPU | Should -Be 90.0
        $result[0].PeakMemoryGB | Should -Be 16.0
        $result[0].PeakDiskGB | Should -Be 80.0
    }

    It 'Groups by different time periods' {
        $testMetrics = @(
            [pscustomobject]@{ VMName = 'vm1'; CPUPercent = 50; MemoryGB = 4; DiskGB = 30; CollectedAt = '2026-02-21T10:00:00' }
            [pscustomobject]@{ VMName = 'vm2'; CPUPercent = 50; MemoryGB = 4; DiskGB = 30; CollectedAt = '2026-02-22T10:00:00' }
        )

        $dayResult = Get-LabResourceTrendCore -VMMetrics $testMetrics -Period Day
        $dayResult | Should -HaveCount 2

        $weekResult = Get-LabResourceTrendCore -VMMetrics $testMetrics -Period Week
        # Both metrics fall in the same week
        $weekResult | Should -HaveCount 1
    }
}

Describe 'Format-LabResourceReport' {
    BeforeEach {
        $testData = @(
            [pscustomobject]@{ VMName = 'dc1'; CPUPercent = 25; MemoryGB = 2; DiskGB = 40 }
            [pscustomobject]@{ VMName = 'svr1'; CPUPercent = 85; MemoryGB = 12; DiskGB = 90 }
            [pscustomobject]@{ VMName = 'ws1'; CPUPercent = 45; MemoryGB = 4; DiskGB = 55 }
        )
    }

    It 'Generates console output with summary statistics' {
        $output = Format-LabResourceReport -ResourceData $testData -Format Console -LabName 'TestLab' 6>&1

        $output | Should -Not -BeNullOrEmpty
        $output | Should -Match 'RESOURCE UTILIZATION REPORT'
        $output | Should -Match 'Avg CPU:'
        $output | Should -Match 'Avg Memory:'
        $output | Should -Match 'Avg Disk:'
    }

    It 'Identifies bottlenecks correctly' {
        $thresholds = @{
            CPUWarning    = 70
            MemoryWarning = 80
            DiskWarning   = 80
        }

        $output = Format-LabResourceReport -ResourceData $testData -Format Console -LabName 'TestLab' -Thresholds $thresholds 6>&1

        $output | Should -Match 'BOTTLENECKS DETECTED'
        $output | Should -Match 'svr1'
    }

    It 'Generates HTML report file' {
        $htmlPath = 'TestDrive:/resources.html'

        $result = Format-LabResourceReport -ResourceData $testData -Format Html -LabName 'TestLab' -OutputPath $htmlPath

        $result | Should -Be $htmlPath
        Test-Path $htmlPath | Should -Be $true

        $content = Get-Content $htmlPath -Raw
        $content | Should -Match '<!DOCTYPE html>'
        $content | Should -Match 'Resource Utilization Report'
        $content | Should -Match 'dc1'
    }

    It 'Generates CSV report file' {
        $csvPath = 'TestDrive:/resources.csv'

        $result = Format-LabResourceReport -ResourceData $testData -Format Csv -LabName 'TestLab' -OutputPath $csvPath

        $result | Should -Be $csvPath
        Test-Path $csvPath | Should -Be $true

        $content = Get-Content $csvPath -Raw
        $content | Should -Match 'VMName'
        $content | Should -Match 'CPUPercent'
    }

    It 'Generates JSON report file with summary' {
        $jsonPath = 'TestDrive:/resources.json'

        $result = Format-LabResourceReport -ResourceData $testData -Format Json -LabName 'TestLab' -OutputPath $jsonPath

        $result | Should -Be $jsonPath
        Test-Path $jsonPath | Should -Be $true

        $content = Get-Content $jsonPath -Raw | ConvertFrom-Json
        $content.LabName | Should -Be 'TestLab'
        $content.Summary.TotalVMs | Should -Be 3
        $content.VMs.Count | Should -Be 3
    }
}
```

These tests follow the Pester 5.x pattern established in Phase 30. They verify time-based aggregation, peak value calculation, bottleneck identification, console output generation, HTML/CSV/JSON file creation, and summary statistics calculation.
  </action>
  <verify>Invoke-Pester -Path Tests/LabResourceReport.Tests.ps1 passes all tests</verify>
<done>Unit tests exist and pass for resource report generation</done>
</task>

</tasks>

<verification>
1. Import module: `Import-Module ./SimpleLab/SimpleLab.psd1` succeeds
2. Test trend aggregation: Get-LabResourceTrendCore correctly groups metrics and calculates averages/peaks
3. Test console report: Get-LabResourceReport -Format Console displays formatted output
4. Test HTML report: Get-LabResourceReport -Format Html -OutputPath 'test.html' creates HTML file
5. Test CSV export: Get-LabResourceReport -Format Csv -OutputPath 'test.csv' creates CSV file
6. Test JSON export: Get-LabResourceReport -Format Json -OutputPath 'test.json' creates JSON file
7. Test trend analysis: Get-LabResourceReport -IncludeTrends includes trend data in JSON output
8. Test module export: Get-Command Get-LabResourceReport returns command info
</verification>

<success_criteria>
1. Get-LabResourceTrendCore aggregates VM metrics by time period (Hour/Day/Week)
2. Format-LabResourceReport generates reports in Console, HTML, CSV, and JSON formats
3. Get-LabResourceReport public API provides operator-facing report generation
4. Resource reports identify bottlenecks based on configurable thresholds
5. Trend analysis integrates historical analytics data with current metrics
6. Get-LabResourceReport is exported from SimpleLab module
7. Unit tests verify resource trend calculation and report generation
</success_criteria>

<output>
After completion, create `.planning/phases/31-advanced-reporting/31-02-SUMMARY.md` with:
- Actual files created with line counts
- Resource report schema documentation
- Bottleneck detection threshold documentation
- Any deviations from plan
- Next steps for Plan 31-03
</output>
