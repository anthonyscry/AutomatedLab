---
phase: 30-lab-analytics
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - Public/Get-LabUsageTrends.ps1
  - Private/Get-LabUsageTrendsCore.ps1
  - Tests/LabUsageTrends.Tests.ps1
autonomous: true
requirements:
  - ANLY-01

must_haves:
  truths:
    - "Operator can view lab usage trends over time (VM uptime, resource consumption patterns)"
    - "Get-LabUsageTrends returns aggregated usage data by time period"
    - "Trend data includes VM uptime hours, deploy frequency, and resource utilization"
    - "Trends can be grouped by day, week, or month"
    - "Usage trends are derived from analytics events and VM metrics"
  artifacts:
    - path: "Public/Get-LabUsageTrends.ps1"
      provides: "Public API for retrieving usage trends"
      exports: ["Get-LabUsageTrends"]
      min_lines: 60
    - path: "Private/Get-LabUsageTrendsCore.ps1"
      provides: "Core trend aggregation logic"
      min_lines: 80
    - path: "Tests/LabUsageTrends.Tests.ps1"
      provides: "Unit tests for trend calculations"
      min_lines: 40
  key_links:
    - from: "Get-LabUsageTrends.ps1"
      to: "Get-LabAnalytics.ps1"
      via: "Reads analytics events for trend calculation"
      pattern: "Get-LabAnalytics"
    - from: "Get-LabUsageTrendsCore.ps1"
      to: "Get-LabVMMetrics.ps1"
      via: "Collects current VM metrics for trend aggregation"
      pattern: "Get-LabVMMetrics"
    - from: "Get-LabUsageTrends.ps1"
      to: "Write-LabAnalyticsEvent.ps1"
      via: "Uses analytics event timestamps for time-based grouping"
      pattern: "Timestamp"
---

<objective>
Create usage trends visualization that aggregates analytics data to show lab usage patterns over time, including VM uptime hours, deployment frequency, and resource consumption trends.

Purpose: Enable operators to understand their lab usage patterns through aggregated metrics grouped by time periods (daily, weekly, monthly), supporting capacity planning and resource optimization decisions.

Output: Get-LabUsageTrends public API with time-based grouping, trend aggregation core logic, and unit tests for trend calculations.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-lab-analytics/30-01-SUMMARY.md

# Existing patterns from codebase (for reference, not to copy)
Public/Get-LabRunHistory.ps1 (Phase 19) - Shows data aggregation with filtering and sorting
Private/Get-LabVMMetrics.ps1 (Phase 29) - Shows metrics collection from VMs
Private/Get-LabUptime.ps1 (Phase 26) - Shows uptime calculation patterns
</context>

<tasks>

<task type="auto">
  <name>Create Get-LabUsageTrendsCore aggregation function</name>
  <files>Private/Get-LabUsageTrendsCore.ps1</files>
  <action>
Create Private/Get-LabUsageTrendsCore.ps1 with core trend aggregation logic:

```powershell
function Get-LabUsageTrendsCore {
    <#
    .SYNOPSIS
        Aggregates lab usage data into time-based trends.

    .DESCRIPTION
        Get-LabUsageTrendsCore processes analytics events and current VM metrics
        to produce aggregated usage trends grouped by time period. Calculates
        deploy counts, total uptime hours, average VM resource usage, and
        operation frequency.

    .PARAMETER Events
        Analytics events array to process.

    .PARAMETER Period
        Grouping period: 'Day', 'Week', 'Month'.

    .PARAMETER VMMetrics
        Current VM metrics to include in trends (optional).

    .OUTPUTS
        [pscustomobject[]] with PeriodStart, PeriodEnd, Deploys, Teardowns,
        TotalUptimeHours, AvgCPU, AvgMemoryGB, AvgDiskGB properties.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject[]])]
    param(
        [Parameter(Mandatory)]
        [pscustomobject[]]$Events,

        [Parameter(Mandatory)]
        [ValidateSet('Day', 'Week', 'Month')]
        [string]$Period,

        [pscustomobject[]]$VMMetrics = @()
    )

    $grouped = @{}

    foreach ($event in $Events) {
        try {
            $timestamp = [DateTime]::Parse($event.Timestamp)
        }
        catch {
            continue
        }

        $periodKey = switch ($Period) {
            'Day'   { $timestamp.ToString('yyyy-MM-dd') }
            'Week'  {
                $culture = [System.Globalization.CultureInfo]::InvariantCulture
                $calendar = $culture.Calendar
                $weekRule = $calendar.GetWeekOfYear($timestamp, [System.Globalization.CalendarWeekRule]::FirstDay, [DayOfWeek]::Monday)
                "$($timestamp.Year)-W$($weekRule.ToString('00'))"
            }
            'Month' { $timestamp.ToString('yyyy-MM') }
        }

        if (-not $grouped.ContainsKey($periodKey)) {
            $grouped[$periodKey] = @{
                PeriodStart   = $timestamp
                PeriodEnd     = $timestamp
                Deploys       = 0
                Teardowns     = 0
                TotalUptime   = 0.0
                VMMetrics     = @()
            }
        }

        $group = $grouped[$periodKey]

        if ($timestamp -lt $group.PeriodStart) {
            $group.PeriodStart = $timestamp
        }
        if ($timestamp -gt $group.PeriodEnd) {
            $group.PeriodEnd = $timestamp
        }

        switch ($event.EventType) {
            'LabDeployed' { $group.Deploys++ }
            'LabTeardown' { $group.Teardowns++ }
        }

        if ($event.Metadata -and $event.Metadata.DurationSeconds) {
            $group.TotalUptime += $event.Metadata.DurationSeconds / 3600.0
        }
    }

    $results = [System.Collections.Generic.List[pscustomobject]]::new()

    foreach ($key in $grouped.Keys | Sort-Object) {
        $group = $grouped[$key]

        $result = [pscustomobject]@{
            Period         = $key
            PeriodStart    = $group.PeriodStart
            PeriodEnd      = $group.PeriodEnd
            Deploys        = $group.Deploys
            Teardowns      = $group.Teardowns
            TotalUptimeHours = [math]::Round($group.TotalUptime, 2)
        }

        if ($VMMetrics.Count -gt 0) {
            $periodMetrics = $VMMetrics | Where-Object {
                $metricTime = $_.CollectedAt ?? [DateTime]::Now
                $metricTime -ge $group.PeriodStart -and $metricTime -le $group.PeriodEnd
            }

            if ($periodMetrics) {
                $result.AvgMemoryGB = [math]::Round(($periodMetrics | Measure-Object -Property MemoryGB -Average).Average, 2)
                $result.AvgDiskGB = [math]::Round(($periodMetrics | Measure-Object -Property DiskGB -Average).Average, 2)
            }
        }

        $results.Add($result)
    }

    return @($results)
}
```

This core function implements time-based grouping logic that processes analytics events into aggregated buckets. It supports Day (yyyy-MM-dd), Week (yyyy-Www), and Month (yyyy-MM) grouping. The function accumulates deploy/teardown counts and uptime hours per period. It optionally incorporates VM metrics for resource usage aggregation. This follows the pattern of Private helper functions that do data processing before Public API presentation.
  </action>
  <verify>Get-LabUsageTrendsCore -Events $testEvents -Period 'Day' returns array grouped by date with Deploys and Teardowns counts</verify>
  <done>Get-LabUsageTrendsCore function exists and groups events by time period correctly</done>
</task>

<task type="auto">
  <name>Create Get-LabUsageTrends public API</name>
  <files>Public/Get-LabUsageTrends.ps1</files>
  <action>
Create Public/Get-LabUsageTrends.ps1 as the public API:

```powershell
function Get-LabUsageTrends {
    <#
    .SYNOPSIS
        Retrieves lab usage trends over time.

    .DESCRIPTION
        Get-LabUsageTrends analyzes analytics events to display lab usage patterns
        including deployment frequency, uptime hours, and resource consumption.
        Trends can be grouped by day, week, or month for different levels of
        granularity.

    .PARAMETER Period
        Time period for grouping: 'Day' (default), 'Week', 'Month'.

    .PARAMETER Days
        Number of recent days to analyze (default 30).

    .PARAMETER LabName
        Filter to events for a specific lab (optional).

    .PARAMETER IncludeCurrentMetrics
        Include current VM metrics in trend calculations (switch).

    .EXAMPLE
        Get-LabUsageTrends
        Returns daily usage trends for the last 30 days.

    .EXAMPLE
        Get-LabUsageTrends -Period Week -Days 90
        Returns weekly usage trends for the last 90 days.

    .EXAMPLE
        Get-LabUsageTrends -LabName 'AutomatedLab' -Period Month
        Returns monthly usage trends for AutomatedLab.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject[]])]
    param(
        [ValidateSet('Day', 'Week', 'Month')]
        [string]$Period = 'Day',

        [int]$Days = 30,

        [string]$LabName,

        [switch]$IncludeCurrentMetrics
    )

    $afterDate = (Get-Date).AddDays(-$Days)

    $getAnalyticsParams = @{
        After = $afterDate
    }

    if ($PSBoundParameters.ContainsKey('LabName')) {
        $getAnalyticsParams.LabName = $LabName
    }

    $events = Get-LabAnalytics @getAnalyticsParams

    $vmMetrics = @()
    if ($IncludeCurrentMetrics) {
        $vmMetrics = Get-LabVMMetrics -VMName $GlobalLabConfig.Lab.CoreVMNames -ErrorAction SilentlyContinue
    }

    $trends = Get-LabUsageTrendsCore -Events $events -Period $Period -VMMetrics $vmMetrics

    return $trends
}
```

This public API follows the pattern established by Get-LabRunHistory (Phase 19) and Get-LabSnapshotInventory (Phase 16). It provides operator-friendly parameters (Period, Days, LabName, IncludeCurrentMetrics) and delegates to a Private core function for the actual processing. The default Period of 'Day' and default Days of 30 provides reasonable defaults for quick usage inspection. The IncludeCurrentMetrics switch integrates with Phase 29's Get-LabVMMetrics function for resource usage data.
  </action>
  <verify>Get-LabUsageTrends -Period Day -Days 7 returns array with 7 or fewer entries, one per day</verify>
  <done>Get-LabUsageTrends public API exists with proper parameter validation and defaults</done>
</task>

<task type="auto">
  <name>Create unit tests for trend calculations</name>
  <files>Tests/LabUsageTrends.Tests.ps1</files>
  <action>
Create Tests/LabUsageTrends.Tests.ps1 with unit tests:

```powershell
Describe 'Get-LabUsageTrends' {
    BeforeAll {
        $moduleRoot = Split-Path -Parent (Split-Path -Parent $PSScriptRoot)
        Import-Module "$moduleRoot\SimpleLab\SimpleLab.psd1" -Force

        . "$moduleRoot\Private\Get-LabUsageTrendsCore.ps1"
        . "$moduleRoot\Private\Get-LabAnalyticsConfig.ps1"

        function New-TestAnalyticsEvent {
            param([DateTime]$Timestamp, [string]$EventType, [string]$LabName = 'TestLab')
            [pscustomobject]@{
                Timestamp = $Timestamp.ToString('o')
                EventType = $EventType
                LabName   = $LabName
                VMNames   = @()
                Metadata  = @{ DurationSeconds = 3600 }
                Host      = 'TESTHOST'
                User      = 'TEST\testuser'
            }
        }
    }

    Context 'Day period grouping' {
        It 'Groups events by day correctly' {
            $events = @(
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-01 08:00:00') -EventType 'LabDeployed'
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-01 14:00:00') -EventType 'LabDeployed'
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-02 10:00:00') -EventType 'LabDeployed'
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-02 16:00:00') -EventType 'LabTeardown'
            )

            $result = Get-LabUsageTrendsCore -Events $events -Period 'Day'

            $result.Count | Should -Be 2
            $result[0].Period | Should -Be '2026-02-01'
            $result[0].Deploys | Should -Be 2
            $result[0].Teardowns | Should -Be 0
            $result[1].Period | Should -Be '2026-02-02'
            $result[1].Deploys | Should -Be 1
            $result[1].Teardowns | Should -Be 1
        }

        It 'Calculates total uptime hours correctly' {
            $events = @(
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-01 08:00:00') -EventType 'LabDeployed'
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-01 14:00:00') -EventType 'LabDeployed'
            )

            $result = Get-LabUsageTrendsCore -Events $events -Period 'Day'

            $result[0].TotalUptimeHours | Should -Be 2.0
        }
    }

    Context 'Week period grouping' {
        It 'Groups events by week correctly' {
            $events = @(
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-01 08:00:00') -EventType 'LabDeployed'
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-08 10:00:00') -EventType 'LabDeployed'
            )

            $result = Get-LabUsageTrendsCore -Events $events -Period 'Week'

            $result.Count | Should -Be 2
            $result[0].Period | Should -Match '^\d{4}-W\d{2}$'
        }
    }

    Context 'Month period grouping' {
        It 'Groups events by month correctly' {
            $events = @(
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-01-15 08:00:00') -EventType 'LabDeployed'
                New-TestAnalyticsEvent -Timestamp (Get-Date '2026-02-01 10:00:00') -EventType 'LabDeployed'
            )

            $result = Get-LabUsageTrendsCore -Events $events -Period 'Month'

            $result.Count | Should -Be 2
            $result[0].Period | Should -Be '2026-01'
            $result[1].Period | Should -Be '2026-02'
        }
    }
}
```

These tests verify the core trend aggregation functionality works correctly. Tests cover day, week, and month period grouping, deploy/teardown counting, and uptime hours calculation. The test pattern follows Pester 5 conventions used throughout the codebase with BeforeAll for setup and Context blocks for logical grouping. The New-TestAnalyticsEvent helper creates realistic test data matching the analytics event schema.
  </action>
  <verify>Invoke-Pester Tests/LabUsageTrends.Tests.ps1 -PassThru | Select-Object -ExpandProperty PassedCount is greater than 0</verify>
  <done>Unit tests exist and verify trend calculation correctness</done>
</task>

<task type="auto">
  <name>Add Get-LabUsageTrends to module exports</name>
  <files>SimpleLab.psm1, SimpleLab.psd1</files>
  <action>
Update both SimpleLab.psm1 and SimpleLab.psd1 to export Get-LabUsageTrends.

In SimpleLab.psm1, add 'Get-LabUsageTrends' to the Export-ModuleMember array.
In SimpleLab.psd1, add 'Get-LabUsageTrends' to the FunctionsToExport array.

This follows the established pattern for public API functions and makes the usage trends functionality available to operators.
  </action>
  <verify>Get-Command Get-LabUsageTrends -Module SimpleLab returns command info</verify>
  <done>Get-LabUsageTrends is exported from the SimpleLab module</done>
</task>

</tasks>

<verification>
1. Import module: `Import-Module ./SimpleLab/SimpleLab.psd1` succeeds
2. Test core function: Get-LabUsageTrendsCore correctly groups test events by period
3. Test public API: Get-LabUsageTrends returns trend data for specified time range
4. Test filtering: Get-LabUsageTrends -LabName 'TestLab' filters by lab
5. Test metrics: Get-LabUsageTrends -IncludeCurrentMetrics includes VM metrics
6. Run tests: Pester tests for trend calculations pass
</verification>

<success_criteria>
1. Get-LabUsageTrendsCore aggregates events by day/week/month correctly
2. Get-LabUsageTrends provides public API with filtering options
3. Trend data includes deploy counts, teardown counts, and uptime hours
4. Current VM metrics can be included via IncludeCurrentMetrics switch
5. Unit tests verify trend calculation accuracy
6. Get-LabUsageTrends is exported from SimpleLab module
</success_criteria>

<output>
After completion, create `.planning/phases/30-lab-analytics/30-02-SUMMARY.md` with:
- Actual files created with line counts
- Trend aggregation algorithm documentation
- Test coverage summary
- Any deviations from plan
- Next steps for Plan 30-03
</output>
