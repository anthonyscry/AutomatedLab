---
phase: 30-lab-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Lab-Config.ps1
  - Private/Write-LabAnalyticsEvent.ps1
  - Public/Get-LabAnalytics.ps1
autonomous: true
requirements:
  - ANLY-03

must_haves:
  truths:
    - "Analytics events are automatically tracked during lab creation, deployment, and teardown operations"
    - "Analytics data persists across PowerShell sessions in a JSON file"
    - "Analytics log file is created in .planning/analytics.json on first event"
    - "Each event includes timestamp, event type, lab name, VM names, and metadata"
    - "Analytics events are written without blocking the main operation"
  artifacts:
    - path: "Lab-Config.ps1"
      provides: "Analytics configuration block with Enabled flag and storage path"
      contains: "Analytics"
    - path: "Private/Write-LabAnalyticsEvent.ps1"
      provides: "Event writing function with append-or-create pattern"
      min_lines: 50
    - path: "Public/Get-LabAnalytics.ps1"
      provides: "Public API for reading analytics log"
      exports: ["Get-LabAnalytics"]
    - path: ".planning/analytics.json"
      provides: "Persistent analytics event storage"
      contains: "events"
  key_links:
    - from: "Write-LabRunArtifacts.ps1"
      to: "Write-LabAnalyticsEvent.ps1"
      via: "Event tracking called after run artifacts written"
      pattern: "Write-LabAnalyticsEvent"
    - from: "Lab-Config.ps1"
      to: "Private/Write-LabAnalyticsEvent.ps1"
      via: "Get-LabAnalyticsConfig helper reads Analytics block"
      pattern: "Get-LabAnalyticsConfig"
---

<objective>
Create the analytics event tracking infrastructure that automatically logs lab lifecycle events (creation, deployment, teardown) to a persistent JSON file.

Purpose: Provide a foundation for lab usage analytics by capturing all significant lab operations in an event log that persists across PowerShell sessions.

Output: Analytics configuration in Lab-Config.ps1, Write-LabAnalyticsEvent helper function, Get-LabAnalytics public API, and .planning/analytics.json storage file.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns from codebase (for reference, not to copy)
Private/Write-LabRunArtifacts.ps1 - Shows JSON artifact writing with run data
Private/Write-LabSTIGCompliance.ps1 - Shows JSON cache update-or-append pattern
Public/Get-LabRunHistory.ps1 - Shows analytics-style data reading from JSON files
</context>

<tasks>

<task type="auto">
  <name>Add Analytics configuration block to Lab-Config.ps1</name>
  <files>Lab-Config.ps1</files>
  <action>
Add the Analytics configuration block to Lab-Config.ps1 after the Dashboard block (around line 252).

The configuration should follow the existing pattern:
```powershell
    Analytics = @{
        # Changing Enabled toggles whether lab analytics events are tracked.
        Enabled = $true
        # Changing StoragePath moves where analytics events are stored.
        StoragePath = '.planning/analytics.json'
        # Changing RetentionDays sets how long to keep analytics events (0 = keep forever).
        RetentionDays = 90
    }
```

This matches the pattern used for TTL, STIG, ADMX, and Dashboard configuration blocks. Enabled defaults to true for analytics (operators want visibility by default, can opt out). StoragePath uses .planning/ directory following the pattern of stig-compliance.json. RetentionDays provides automatic cleanup capability.
  </action>
  <verify>Test-Path variable:LabConfig.Analytics returns $true after dot-sourcing Lab-Config.ps1</verify>
  <done>Analytics block exists in Lab-Config.ps1 with Enabled, StoragePath, and RetentionDays keys</done>
</task>

<task type="auto">
  <name>Create Get-LabAnalyticsConfig helper function</name>
  <files>Private/Get-LabAnalyticsConfig.ps1</files>
  <action>
Create Private/Get-LabAnalyticsConfig.ps1 following the exact pattern of Get-LabTTLConfig, Get-LabSTIGConfig, and Get-LabDashboardConfig:

```powershell
function Get-LabAnalyticsConfig {
    <#
    .SYNOPSIS
        Reads analytics configuration from global lab config.

    .DESCRIPTION
        Get-LabAnalyticsConfig returns an Analytics configuration object with safe
        defaults when keys are missing from $GlobalLabConfig. Contains ContainsKey
        guards for all nested keys to prevent errors under StrictMode.

    .OUTPUTS
        [pscustomobject] with Enabled, StoragePath, RetentionDays properties.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param()

    $config = $GlobalLabConfig

    $enabled = if ($config.ContainsKey('Analytics') -and $config.Analytics.ContainsKey('Enabled')) {
        [bool]$config.Analytics.Enabled
    } else {
        $true
    }

    $storagePath = if ($config.ContainsKey('Analytics') -and $config.Analytics.ContainsKey('StoragePath')) {
        [string]$config.Analytics.StoragePath
    } else {
        '.planning/analytics.json'
    }

    $retentionDays = if ($config.ContainsKey('Analytics') -and $config.Analytics.ContainsKey('RetentionDays')) {
        [int]$config.Analytics.RetentionDays
    } else {
        90
    }

    return [pscustomobject]@{
        Enabled       = $enabled
        StoragePath   = $storagePath
        RetentionDays = $retentionDays
    }
}
```

This function follows the established pattern from Phase 26 (Get-LabTTLConfig), Phase 27 (Get-LabSTIGConfig), and Phase 29 (Get-LabDashboardConfig). It provides ContainsKey guards for safe config access under StrictMode, returns type-casted values with safe defaults, and exports a PSCustomObject with all configuration fields.
  </action>
  <verify>Get-LabAnalyticsConfig returns PSCustomObject with Enabled, StoragePath, RetentionDays properties set to $true, '.planning/analytics.json', 90 when Analytics block missing from $GlobalLabConfig</verify>
  <done>Get-LabAnalyticsConfig helper exists and follows established config helper pattern</done>
</task>

<task type="auto">
  <name>Create Write-LabAnalyticsEvent function</name>
  <files>Private/Write-LabAnalyticsEvent.ps1</files>
  <action>
Create Private/Write-LabAnalyticsEvent.ps1 that implements append-or-create event tracking:

```powershell
function Write-LabAnalyticsEvent {
    <#
    .SYNOPSIS
        Writes an analytics event to the lab analytics log.

    .DESCRIPTION
        Write-LabAnalyticsEvent appends a new event record to the analytics log,
        creating the file if it doesn't exist. Events include timestamp, event
        type, lab name, VM names, and optional metadata. Non-blocking operation
        that logs errors but doesn't throw.

    .PARAMETER EventType
        Type of event: 'LabCreated', 'LabDeployed', 'LabTeardown', 'LabExported',
        'LabImported', 'ProfileSaved', 'ProfileLoaded', etc.

    .PARAMETER LabName
        Name of the lab this event relates to.

    .PARAMETER VMNames
        Array of VM names affected by this event (optional).

    .PARAMETER Metadata
        Additional event metadata as hashtable (optional).

    .EXAMPLE
        Write-LabAnalyticsEvent -EventType 'LabDeployed' -LabName 'AutomatedLab' -VMNames @('dc1', 'svr1')
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$EventType,

        [Parameter(Mandatory)]
        [string]$LabName,

        [string[]]$VMNames = @(),

        [hashtable]$Metadata = @{}
    )

    try {
        $analyticsConfig = Get-LabAnalyticsConfig

        if (-not $analyticsConfig.Enabled) {
            return
        }

        $storagePath = $analyticsConfig.StoragePath
        $parentDir = Split-Path -Parent $storagePath

        if (-not [string]::IsNullOrWhiteSpace($parentDir) -and -not (Test-Path $parentDir)) {
            $null = New-Item -Path $parentDir -ItemType Directory -Force
            Write-Verbose "Created directory: $parentDir"
        }

        $event = [pscustomobject]@{
            Timestamp = Get-Date -Format 'o'
            EventType = $EventType
            LabName   = $LabName
            VMNames   = @($VMNames)
            Metadata  = if ($Metadata.Count -gt 0) { $Metadata } else { $null }
            Host      = $env:COMPUTERNAME
            User      = "$env:USERDOMAIN\$env:USERNAME"
        }

        if ((Test-Path $storagePath)) {
            $existing = Get-Content -Raw -Path $storagePath | ConvertFrom-Json
            if ($existing.events) {
                $existing.events += @($event)
            } else {
                $existing = [pscustomobject]@{ events = @($event) }
            }
        } else {
            $existing = [pscustomobject]@{ events = @($event) }
        }

        $existing | ConvertTo-Json -Depth 8 | Set-Content -Path $storagePath -Encoding UTF8
    }
    catch {
        Write-Warning "Write-LabAnalyticsEvent: failed to write analytics event to '$storagePath' - $_"
    }
}
```

This function follows the cache-on-write pattern from Phase 27 (Write-LabSTIGCompliance). It reads the existing JSON file, appends the new event to the events array, and writes back. It includes graceful degradation when analytics is disabled or file operations fail. The event structure matches the existing run artifact pattern with Timestamp, EventType, LabName, VMNames, Metadata, Host, and User fields.
  </action>
  <verify>Write-LabAnalyticsEvent -EventType 'Test' -LabName 'TestLab' creates .planning/analytics.json with events array containing the test event</verify>
  <done>Write-LabAnalyticsEvent function exists and creates/updates analytics log file correctly</done>
</task>

<task type="auto">
  <name>Create Get-LabAnalytics public API</name>
  <files>Public/Get-LabAnalytics.ps1</files>
  <action>
Create Public/Get-LabAnalytics.ps1 for reading analytics events:

```powershell
function Get-LabAnalytics {
    <#
    .SYNOPSIS
        Retrieves lab analytics events from the analytics log.

    .DESCRIPTION
        Get-LabAnalytics reads analytics events from the analytics JSON file and
        returns either all events or filtered events by type, date range, or lab name.
        Events are sorted by timestamp descending (newest first).

    .PARAMETER EventType
        Filter to events of this type only (optional).

    .PARAMETER LabName
        Filter to events for this lab only (optional).

    .PARAMETER After
        Only include events after this DateTime (optional).

    .PARAMETER Before
        Only include events before this DateTime (optional).

    .PARAMETER Last
        Return only the last N events (optional, default 100).

    .EXAMPLE
        Get-LabAnalytics
        Returns all analytics events, newest 100.

    .EXAMPLE
        Get-LabAnalytics -EventType 'LabDeployed'
        Returns only LabDeployed events.

    .EXAMPLE
        Get-LabAnalytics -LabName 'AutomatedLab' -Last 10
        Returns last 10 events for AutomatedLab.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject[]])]
    param(
        [string]$EventType,
        [string]$LabName,
        [DateTime]$After,
        [DateTime]$Before,
        [int]$Last = 100
    )

    $analyticsConfig = Get-LabAnalyticsConfig
    $storagePath = $analyticsConfig.StoragePath

    if (-not (Test-Path $storagePath)) {
        Write-Warning "Analytics file not found at '$storagePath'"
        return @()
    }

    try {
        $data = Get-Content -Raw -Path $storagePath | ConvertFrom-Json
        $events = if ($data.events) { @($data.events) } else { @() }
    }
    catch {
        Write-Warning "Failed to read analytics file '$storagePath': $($_.Exception.Message)"
        return @()
    }

    $filtered = $events

    if ($PSBoundParameters.ContainsKey('EventType')) {
        $filtered = @($filtered | Where-Object { $_.EventType -eq $EventType })
    }

    if ($PSBoundParameters.ContainsKey('LabName')) {
        $filtered = @($filtered | Where-Object { $_.LabName -eq $LabName })
    }

    if ($PSBoundParameters.ContainsKey('After')) {
        $filtered = @($filtered | Where-Object { [DateTime]::Parse($_.Timestamp) -gt $After })
    }

    if ($PSBoundParameters.ContainsKey('Before')) {
        $filtered = @($filtered | Where-Object { [DateTime]::Parse($_.Timestamp) -lt $Before })
    }

    $sorted = @($filtered | Sort-Object -Property @{ Expression = { [DateTime]::Parse($_.Timestamp) }; Descending = $true })

    return @($sorted | Select-Object -First $Last)
}
```

This function follows the read-and-filter pattern from Get-LabRunHistory (Phase 19). It supports multiple filter parameters with PSBoundParameters.ContainsKey checks for conditional filtering. It returns events sorted newest-first with a configurable limit. This provides the foundation for the usage trends functionality in Plan 02.
  </action>
  <verify>Get-LabAnalytics returns events array sorted by timestamp descending (newest first)</verify>
  <done>Get-LabAnalytics public API exists with filtering and sorting capabilities</done>
</task>

<task type="auto">
  <name>Integrate analytics tracking into lifecycle operations</name>
  <files>Private/Write-LabRunArtifacts.ps1</files>
  <action>
Modify Private/Write-LabRunArtifacts.ps1 to automatically track analytics events after writing run artifacts.

Add this code at the end of the try block, after the Set-Content calls (around line 97):

```powershell
# Track analytics event based on action type
$analyticsEventType = switch ($ReportData.Action) {
    'bootstrap' { 'LabDeployed' }
    'deploy'    { 'LabDeployed' }
    'teardown'  { 'LabTeardown' }
    default     { "Lab$($ReportData.Action)" }
}

$analyticsMetadata = [ordered]@{
    Action            = $ReportData.Action
    Mode              = $ReportData.EffectiveMode
    Success           = $Success
    DurationSeconds   = $duration
    RunId             = $runId
}

if ($ReportData.VMNames -and $ReportData.VMNames.Count -gt 0) {
    $analyticsMetadata.VMCount = $ReportData.VMNames.Count
}

Write-LabAnalyticsEvent -EventType $analyticsEventType -LabName $ReportData.LabName -VMNames $ReportData.VMNames -Metadata $analyticsMetadata
```

This integration automatically tracks all lab lifecycle events (bootstrap, deploy, teardown) by leveraging the existing Write-LabRunArtifacts call site. The action type is mapped to an appropriate analytics event type. Metadata includes Action, Mode, Success, Duration, RunId, and VMCount for rich analytics data. This follows the pattern established in Phase 27 where STIG compliance was integrated into DC.ps1 PostInstall and Phase 28 where ADMX operations were integrated into lifecycle workflows.
  </action>
  <verify>After running a lab operation, .planning/analytics.json contains an event with EventType matching the operation (LabDeployed, LabTeardown, etc.)</verify>
  <done>Analytics events are automatically tracked during lab lifecycle operations</done>
</task>

<task type="auto">
  <name>Add Get-LabAnalytics to module exports</name>
  <files>SimpleLab.psm1, SimpleLab.psd1</files>
  <action>
Update both SimpleLab.psm1 and SimpleLab.psd1 to export Get-LabAnalytics.

In SimpleLab.psm1 (around line 40), add 'Get-LabAnalytics' to the Export-ModuleMember array:
```powershell
Export-ModuleMember -Function @(
    'Test-HyperVEnabled',
    'Get-LabAnalytics',
    # ... rest of exports
)
```

In SimpleLab.psd1, add 'Get-LabAnalytics' to the FunctionsToExport array.

This follows the established pattern for public API functions. The function is now available for operators to query analytics data directly from PowerShell, and will be used by the usage trends functionality in Plan 02.
  </action>
  <verify>Get-Command Get-LabAnalytics -Module SimpleLab returns command info</verify>
  <done>Get-LabAnalytics is exported from the SimpleLab module</done>
</task>

</tasks>

<verification>
1. Import module: `Import-Module ./SimpleLab/SimpleLab.psd1` succeeds
2. Test config: Get-LabAnalyticsConfig returns object with Enabled=true, StoragePath='.planning/analytics.json', RetentionDays=90
3. Test write: Write-LabAnalyticsEvent -EventType 'TestEvent' -LabName 'TestLab' creates .planning/analytics.json
4. Test read: Get-LabAnalytics returns events array
5. Test integration: Run a lab operation, verify analytics event was tracked
</verification>

<success_criteria>
1. Analytics configuration block exists in Lab-Config.ps1
2. Write-LabAnalyticsEvent function creates/updates .planning/analytics.json
3. Get-LabAnalytics reads analytics events with filtering support
4. Analytics events are automatically tracked during lifecycle operations
5. Analytics data persists across PowerShell sessions
6. Get-LabAnalytics is exported from SimpleLab module
</success_criteria>

<output>
After completion, create `.planning/phases/30-lab-analytics/30-01-SUMMARY.md` with:
- Actual files created with line counts
- Analytics event schema documentation
- Integration points verified
- Any deviations from plan
- Next steps for Plan 30-02
</output>
