---
phase: 29
plan: 03
title: Background Runspace for Metric Collection
type: standard
wave: 2
depends_on: ["29-02"]
files_modified:
  - GUI/Start-OpenCodeLabGUI.ps1
autonomous: true
requirements:
  - DASH-05
must_haves:
  - Synchronized hashtable ($DashboardMetrics) for thread-safe data sharing
  - Start-DashboardMetricsRefreshRunspace function creates STA runspace
  - Stop-DashboardMetricsRefreshRunspace function disposes runspace on window close
  - 60-second collection loop with Continue flag for clean shutdown
  - Error handling prevents runspace crashes (isolates metric failures)
---

## Objective

Implement the background runspace infrastructure that collects VM metrics every 60 seconds without blocking the UI thread. The runspace writes to a synchronized hashtable that the UI thread reads from.

## Context

@phase-context: .planning/phases/29-dashboard-enrichment/29-CONTEXT.md
@research: .planning/phases/29-dashboard-enrichment/29-RESEARCH.md
@metrics-helpers: Private/Get-LabVMMetrics.ps1 (created in plan 29-02)
@timer-pattern: GUI/Start-OpenCodeLabGUI.ps1 (existing 5-second VMPollTimer pattern)

Per CONTEXT.md decision: 60-second refresh interval separate from 5-second DispatcherTimer. Synchronized hashtable pattern from Microsoft docs. Runspace disposed on window close. Collection failures don't crash dashboard (show Unknown).

## Tasks

### Task 1: Add synchronized hashtable initialization

**Type:** auto

**Files:**
- GUI/Start-OpenCodeLabGUI.ps1

**Action:**
Add the synchronized hashtable initialization after the existing script variables (around line 310, after $script:VMRoles):

```powershell
# ── Dashboard metrics hashtable (thread-safe for background runspace) ──
$script:DashboardMetrics = [System.Collections.Hashtable]::Synchronized(@{})
# Populate with empty hashtables for each VM name to avoid KeyNotFoundException
$script:DashboardMetrics['Continue'] = $true  # Flag to control runspace loop
```

Place this after the $script:VMRoles definition (after line 308). The 'Continue' flag is used by the runspace loop to know when to exit cleanly.

**Verify:**
- $script:DashboardMetrics exists after GUI script loads
- $script:DashboardMetrics.GetType().Name contains 'Synchronized'
- $script:DashboardMetrics['Continue'] equals $true

**Done:**
Synchronized hashtable initialized for thread-safe data sharing between background runspace and UI thread.

### Task 2: Create Start-DashboardMetricsRefreshRunspace function

**Type:** auto

**Files:**
- GUI/Start-OpenCodeLabGUI.ps1

**Action:**
Add the Start-DashboardMetricsRefreshRunspace function after the Update-VMCard function (around line 403):

```powershell
# ── Dashboard metrics background refresh runspace ────────────────────────
function Start-DashboardMetricsRefreshRunspace {
    <#
    .SYNOPSIS
        Creates and starts a background runspace for periodic VM metrics collection.

    .DESCRIPTION
        Creates a PowerShell runspace with STA apartment state (required for WPF
        compatibility). The runspace runs a 60-second collection loop that queries
        VM metrics and updates the synchronized hashtable. Returns a hashtable with
        Runspace, PowerShell, and Handle objects for later disposal.
    #>
    [CmdletBinding()]
    [OutputType([hashtable])]
    param()

    # Create the runspace with STA apartment state
    $runspace = [runspacefactory]::CreateRunspace()
    $runspace.ApartmentState = 'STA'
    $runspace.ThreadOptions = 'ReuseThread'

    # Add variables to the runspace for script block access
    $runspace.Open()

    # Create PowerShell instance and add the script
    $ps = [powershell]::Create()
    $ps.Runspace = $runspace

    # Get VM names from config or use defaults
    $vmNames = if ((Test-Path variable:GlobalLabConfig) -and $GlobalLabConfig.Lab.CoreVMNames) {
        @($GlobalLabConfig.Lab.CoreVMNames)
    } else {
        @('dc1', 'svr1', 'ws1')
    }

    # Build the collection script block
    $collectionScript = {
        param($syncHash, $vmList)

        # Import required functions (they're in the same session)
        # Note: Private/Public functions are already loaded in parent scope

        while ($syncHash['Continue']) {
            try {
                # Collect metrics for all VMs
                foreach ($vmName in $vmList) {
                    $metrics = Get-LabVMMetrics -VMName $vmName -ErrorAction SilentlyContinue

                    if ($metrics) {
                        # Store in synchronized hashtable
                        $syncHash[$vmName] = @{
                            SnapshotAge      = $metrics.SnapshotAge
                            DiskUsageGB      = $metrics.DiskUsageGB
                            DiskUsagePercent = $metrics.DiskUsagePercent
                            UptimeHours      = $metrics.UptimeHours
                            STIGStatus       = $metrics.STIGStatus
                        }
                    }
                }

                # Update LastUpdated timestamp
                $syncHash['LastUpdated'] = Get-Date
            }
            catch {
                # Silently log errors - don't crash the runspace
                $syncHash['LastError'] = (Get-Date).ToString() + ": $($_.Exception.Message)"
            }

            # Wait 60 seconds before next collection
            Start-Sleep -Seconds 60
        }
    }.GetNewClosure()

    # Add parameters to the script
    $null = $ps.AddScript($collectionScript).AddParameter('syncHash', $script:DashboardMetrics).AddParameter('vmList', $vmNames)

    # Invoke the script asynchronously
    $handle = $ps.BeginInvoke()

    # Return the runspace info for later cleanup
    return @{
        Runspace  = $runspace
        PowerShell = $ps
        Handle    = $handle
    }
}
```

Key implementation notes:
- STA apartment state required for WPF compatibility
- 'Continue' flag in hashtable controls the while loop
- 60-second Start-Sleep between collections
- Error handling with try/catch prevents crashes
- LastUpdated timestamp for debugging
- VM names captured at runspace creation (not re-read on each loop)

**Verify:**
- Function exists in GUI/Start-OpenCodeLabGUI.ps1
- Returns hashtable with Runspace, PowerShell, Handle keys
- Runspace ApartmentState is 'STA'
- Script block references $script:DashboardMetrics correctly

**Done:**
Start-DashboardMetricsRefreshRunspace function creates background runspace with 60-second collection loop.

### Task 3: Create Stop-DashboardMetricsRefreshRunspace function

**Type:** auto

**Files:**
- GUI/Start-OpenCodeLabGUI.ps1

**Action:**
Add the Stop-DashboardMetricsRefreshRunspace function after Start-DashboardMetricsRefreshRunspace:

```powershell
function Stop-DashboardMetricsRefreshRunspace {
    <#
    .SYNOPSIS
        Stops and disposes the dashboard metrics refresh runspace.

    .DESCRIPTION
        Sets the Continue flag to false, waits for the runspace to complete,
        then disposes the PowerShell instance and runspace. Called from the
        window Closing event handler to prevent resource leaks.
    #>
    [CmdletBinding()]
    param()

    if ($null -ne $script:MetricsRefreshRunspace) {
        # Signal the runspace to exit
        $script:DashboardMetrics['Continue'] = $false

        # Wait for the runspace to finish (max 5 seconds)
        if (-not $script:MetricsRefreshRunspace.Handle.IsCompleted) {
            $script:MetricsRefreshRunspace.Handle.AsyncWaitHandle.WaitOne(5000) | Out-Null
        }

        # Stop and dispose
        try {
            $script:MetricsRefreshRunspace.PowerShell.Stop()
            $script:MetricsRefreshRunspace.PowerShell.Dispose()
            $script:MetricsRefreshRunspace.Runspace.Dispose()
        }
        catch {
            # Dispose errors are non-critical
        }

        $script:MetricsRefreshRunspace = $null
    }
}
```

Key implementation notes:
- Sets 'Continue' flag to false to signal loop exit
- Waits up to 5 seconds for graceful shutdown
- Disposes PowerShell instance and Runspace
- Handles dispose errors gracefully (try/catch)
- Sets $script:MetricsRefreshRunspace to $null after cleanup

**Verify:**
- Function exists in GUI/Start-OpenCodeLabGUI.ps1
- Sets Continue flag to false
- Calls Stop() and Dispose() on PowerShell and Runspace

**Done:**
Stop-DashboardMetricsRefreshRunspace function cleanly disposes the runspace resources.

### Task 4: Wire runspace to dashboard lifecycle

**Type:** auto

**Files:**
- GUI/Start-OpenCodeLabGUI.ps1

**Action:**
Modify the Initialize-DashboardView function to start the runspace, and update the window Closing handler to stop it.

First, add this code at the end of Initialize-DashboardView (after the timer starts, around line 815):

```powershell
    # ── Start background metrics refresh runspace ────────────────────
    if ($null -eq $script:MetricsRefreshRunspace) {
        $script:MetricsRefreshRunspace = Start-DashboardMetricsRefreshRunspace
    }
```

Second, modify the existing window Closing handler (around line 295) to also stop the metrics runspace:

```powershell
# ── Window Closing handler (cleanup timers and runspaces) ─────────────
$mainWindow.Add_Closing({
    # Stop VM poll timer
    if ($null -ne $script:VMPollTimer) {
        $script:VMPollTimer.Stop()
        $script:VMPollTimer = $null
    }

    # Stop metrics refresh runspace
    Stop-DashboardMetricsRefreshRunspace
})
```

**Verify:**
- Initialize-DashboardView calls Start-DashboardMetricsRefreshRunspace
- Window Closing handler calls Stop-DashboardMetricsRefreshRunspace
- $script:MetricsRefreshRunspace is initialized once (not duplicated on dashboard revisits)

**Done:**
Background runspace starts on dashboard view load and stops on window close. No resource leaks.

### Task 5: Add runspace lifecycle tests

**Type:** auto

**Files:**
- Tests/LabDashboardMetricsRunspace.Tests.ps1

**Action:**
Create Tests/LabDashboardMetricsRunspace.Tests.ps1 to verify runspace lifecycle:

```powershell
BeforeAll {
    # Source the GUI script to load functions
    $guiScript = Join-Path $PSScriptRoot "../GUI/Start-OpenCodeLabGUI.ps1"

    # Mock WPF assemblies to avoid loading them in tests
    Mock Add-Type { }
    Mock Import-XamlFile { return New-Object System.Windows.Controls.Grid }

    # Mock VM queries
    Mock Get-LabVMMetrics {
        return [pscustomobject]@{
            VMName            = 'testvm'
            SnapshotAge       = 10
            DiskUsageGB       = 45.0
            DiskUsagePercent  = 90
            UptimeHours       = 5.5
            STIGStatus        = 'Compliant'
        }
    }

    # Mock Lab-Config.ps1 loading
    $GlobalLabConfig = @{
        Lab = @{
            CoreVMNames = @('dc1', 'svr1', 'ws1')
        }
    }
}

Describe 'Dashboard Metrics Runspace' {
    It 'Start-DashboardMetricsRefreshRunspace creates runspace with STA apartment state' {
        # Source the function (skip the rest of GUI script setup)
        . $PSScriptRoot/../GUI/Start-OpenCodeLabGUI.ps1

        $runspaceInfo = Start-DashboardMetricsRefreshRunspace

        $runspaceInfo | Should -Not -Be $null
        $runspaceInfo.Runspace | Should -Not -Be $null
        $runspaceInfo.PowerShell | Should -Not -Be $null
        $runspaceInfo.Handle | Should -Not -Be $null
        $runspaceInfo.Runspace.ApartmentState | Should -Be 'STA'
    }

    It 'Runspace populates synchronized hashtable with metrics' {
        $syncHash = [System.Collections.Hashtable]::Synchronized(@{})
        $syncHash['Continue'] = $true
        $script:DashboardMetrics = $syncHash

        $runspaceInfo = Start-DashboardMetricsRefreshRunspace

        # Wait for first collection (allow up to 65 seconds for 60s loop)
        $timeout = 65
        $elapsed = 0
        while (-not $syncHash.ContainsKey('LastUpdated') -and $elapsed -lt $timeout) {
            Start-Sleep -Seconds 1
            $elapsed++
        }

        $syncHash.ContainsKey('LastUpdated') | Should -Be $true
        $syncHash['dc1'] | Should -Not -Be $null
        $syncHash['dc1'].STIGStatus | Should -Be 'Compliant'
    }

    It 'Stop-DashboardMetricsRefreshRunspace disposes runspace cleanly' {
        $runspaceInfo = Start-DashboardMetricsRefreshRunspace
        $script:MetricsRefreshRunspace = $runspaceInfo

        Stop-DashboardMetricsRefreshRunspace

        $script:MetricsRefreshRunspace | Should -Be $null
        $syncHash['Continue'] | Should -Be $false
    }
}
```

**Verify:**
- All 3 tests pass
- Runspace creation verified (STA state)
- Hashtable population verified (metrics written)
- Clean disposal verified (Continue flag false, resources released)

**Done:**
LabDashboardMetricsRunspace.Tests.ps1 created with lifecycle tests. All tests pass.

---

## Verification Criteria

1. **Synchronized Hashtable**: $script:DashboardMetrics initialized with 'Continue' flag
2. **Start Function**: Creates STA runspace, 60-second loop, writes metrics to hashtable
3. **Stop Function**: Sets Continue=false, waits for completion, disposes resources
4. **Lifecycle Integration**: Runs on dashboard load, stops on window close
5. **Unit Tests**: Lifecycle tests verify creation, population, and disposal

## Success Metrics

- Start-DashboardMetricsRefreshRunspace returns hashtable with Runspace, PowerShell, Handle keys
- Runspace.ApartmentState equals 'STA'
- $script:DashboardMetrics contains VM entries after 60 seconds
- No PowerShell.exe processes remain after GUI closes
- Window close completes within 5 seconds (runspace disposes promptly)
