---
phase: 28
plan: 02
title: AD Readiness Gate and ADMX Import Core
type: standard
wave: 2
depends_on:
  - 28-01
files_modified:
  - Private/Wait-LabADReady.ps1
  - Private/Invoke-LabADMXImport.ps1
  - Tests/LabADMXImport.Tests.ps1
  - Tests/Wait-LabADReady.Tests.ps1
autonomous: true
requirements:
  - GPO-01
  - GPO-04
must_haves:
  - Wait-LabADReady helper with Get-ADDomain retry loop (120s timeout, 10s interval)
  - Invoke-LabADMXImport that copies ADMX/ADML from DC PolicyDefinitions to Central Store
  - Third-party ADMX import from config-specified paths (no internet download)
  - Result object pattern with FilesImported, GPOsCreated, Success, DurationSeconds
---

## Objective

Create the Wait-LabADReady helper that gates on ADWS readiness using Get-ADDomain, and the Invoke-LabADMXImport helper that copies ADMX/ADML files from the DC's PolicyDefinitions to the SYSVOL Central Store and optionally imports third-party ADMX bundles.

## Context

@phase-context: .planning/phases/28-admx-gpo-auto-import/28-CONTEXT.md
@research: .planning/phases/28-admx-gpo-auto-import/28-RESEARCH.md
@config-reader: Private/Get-LabADMXConfig.ps1 (from 28-01)
@result-pattern: Private/Invoke-LabSTIGBaselineCore.ps1 (lines 1-50, 280-298)
@postinstall-pattern: LabBuilder/Roles/DC.ps1 (lines 78-101)

Per CONTEXT.md decision: Wait-LabADReady helper gates on Get-ADDomain success (not just WinRM responsiveness) with retry loop (default 120 seconds, 10-second intervals). Returns [pscustomobject] with Ready (bool), DomainName, WaitSeconds fields.

Per CONTEXT.md decision: Invoke-LabADMXImport copies ADMX/ADML files from DC's C:\Windows\PolicyDefinitions to \\domain\SYSVOL\domain\Policies\PolicyDefinitions (Central Store). Uses Copy-Item -Recurse via Invoke-Command on the DC. Idempotent: overwrites existing files without error.

## Tasks

### Task 1: Create Wait-LabADReady helper function

**Type:** auto

**Files:**
- Private/Wait-LabADReady.ps1

**Action:**
Create Private/Wait-LabADReady.ps1 implementing ADWS readiness gating:

```powershell
function Wait-LabADReady {
    <#
    .SYNOPSIS
        Waits for Active Directory Web Services (ADWS) to become ready after DC promotion.

    .DESCRIPTION
        Gates ADMX/GPO operations on ADWS readiness by polling Get-ADDomain until success
        or timeout. This eliminates the race condition where DC promotion returns before
        ADWS is fully responsive.

    .PARAMETER DomainName
        The Active Directory domain name to query (e.g., 'simplelab.local').

    .PARAMETER TimeoutSeconds
        Maximum seconds to wait for ADWS readiness. Default is 120 seconds.

    .PARAMETER RetryIntervalSeconds
        Seconds between Get-ADDomain retry attempts. Default is 10 seconds.

    .OUTPUTS
        PSCustomObject with Ready (bool), DomainName (string), WaitSeconds (int) fields.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory)]
        [string]$DomainName,

        [int]$TimeoutSeconds = 120,

        [int]$RetryIntervalSeconds = 10
    )

    $startTime = Get-Date
    $elapsed = 0
    $ready = $false

    while (-not $ready -and $elapsed -lt $TimeoutSeconds) {
        try {
            # Get-ADDomain validates full ADWS functionality
            $domain = Get-ADDomain -Identity $DomainName -ErrorAction Stop
            $ready = $true
            Write-Verbose "[Wait-LabADReady] ADWS is ready for domain '$DomainName'"
        }
        catch {
            Write-Verbose "[Wait-LabADReady] ADWS not ready yet: $($_.Exception.Message)"
            Start-Sleep -Seconds $RetryIntervalSeconds
        }
        $elapsed = [int]((Get-Date) - $startTime).TotalSeconds
    }

    return [pscustomobject]@{
        Ready      = $ready
        DomainName = $DomainName
        WaitSeconds = $elapsed
    }
}
```

Key implementation details:
- Loop until Get-ADDomain succeeds OR timeout exceeded
- Get-ADDomain is called with -ErrorAction Stop to ensure exceptions are caught
- Elapsed time calculated as integer seconds
- Returns object matching Invoke-LabQuickModeHeal pattern (bool Ready, metrics)
- Verbose logging for each retry attempt

**Verify:**
- Function loads without error when dot-sourced
- Returns Ready=$true when ADWS is already responsive
- Returns Ready=$false after timeout when domain doesn't exist
- WaitSeconds reflects actual wait time (not full timeout on early success)
- Parameter validation: DomainName is mandatory

**Done:**
Wait-LabADReady.ps1 exists in Private/ with Get-ADDomain retry loop, 120s default timeout, 10s retry interval.

### Task 2: Create Invoke-LabADMXImport helper function

**Type:** auto

**Files:**
- Private/Invoke-LabADMXImport.ps1

**Action:**
Create Private/Invoke-LabADMXImport.ps1 implementing ADMX Central Store population and third-party ADMX import. This is a complex function - follow the structure carefully:

```powershell
function Invoke-LabADMXImport {
    <#
    .SYNOPSIS
        Populates the ADMX Central Store and optionally imports third-party ADMX bundles.

    .DESCRIPTION
        Copies ADMX/ADML files from the DC's PolicyDefinitions directory to the
        SYSVOL Central Store. When ThirdPartyADMX entries are present in config,
        also copies ADMX bundles from operator-specified local paths. GPO creation
        is NOT performed by this function (see plan 28-03 for baseline GPOs).

    .PARAMETER DCName
        The domain controller VM name.

    .PARAMETER DomainName
        The Active Directory domain name (e.g., 'simplelab.local').

    .OUTPUTS
        PSCustomObject with FilesImported (int), Success (bool), CentralStorePath (string),
        ThirdPartyBundlesProcessed (int), DurationSeconds (int), Message (string) fields.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$DCName,

        [Parameter(Mandatory)]
        [string]$DomainName
    )

    $startTime = Get-Date
    $filesImported = 0
    $thirdPartyBundles = 0
    $message = ''

    # Build Central Store path: \\domain\SYSVOL\domain\Policies\PolicyDefinitions
    $centralStorePath = "\\$DomainName\SYSVOL\$DomainName\Policies\PolicyDefinitions"

    try {
        # Ensure Central Store directory exists
        if (-not (Test-Path $centralStorePath)) {
            New-Item -ItemType Directory -Path $centralStorePath -Force | Out-Null
            Write-Verbose "[Invoke-LabADMXImport] Created Central Store: $centralStorePath"
        }

        # Copy OS ADMX/ADML from DC's PolicyDefinitions to Central Store
        Write-Verbose "[Invoke-LabADMXImport] Copying OS ADMX/ADML from $DCName..."
        $copyResult = Invoke-Command -ComputerName $DCName -ScriptBlock {
            param($centralStorePath)

            $sourcePath = 'C:\Windows\PolicyDefinitions'
            $filesCopied = 0

            # Copy all .admx files from root
            $admxFiles = Get-ChildItem -Path $sourcePath -Filter '*.admx' -ErrorAction SilentlyContinue
            foreach ($file in $admxFiles) {
                $destPath = Join-Path $centralStorePath $file.Name
                Copy-Item -Path $file.FullName -Destination $destPath -Force
                $filesCopied++
            }

            # Copy ADML subdirectories (en-US, etc.)
            $admlDirs = Get-ChildItem -Path $sourcePath -Directory -ErrorAction SilentlyContinue
            foreach ($dir in $admlDirs) {
                $destDir = Join-Path $centralStorePath $dir.Name
                if (-not (Test-Path $destDir)) {
                    New-Item -ItemType Directory -Path $destDir -Force | Out-Null
                }
                $admlFiles = Get-ChildItem -Path (Join-Path $sourcePath $dir.Name) -Filter '*.adml' -ErrorAction SilentlyContinue
                foreach ($file in $admlFiles) {
                    Copy-Item -Path $file.FullName -Destination $destDir -Force
                    $filesCopied++
                }
            }

            return $filesCopied
        } -ArgumentList $centralStorePath

        $filesImported += $copyResult
        Write-Verbose "[Invoke-LabADMXImport] Copied $copyResult OS ADMX/ADML files to Central Store"

        # Process third-party ADMX bundles if configured
        $config = Get-LabADMXConfig
        foreach ($bundle in $config.ThirdPartyADMX) {
            $bundleName = $bundle.Name
            $bundlePath = $bundle.Path

            Write-Verbose "[Invoke-LabADMXImport] Processing third-party bundle: $bundleName from $bundlePath"

            # Validate bundle path exists
            if (-not (Test-Path $bundlePath)) {
                Write-Warning "[Invoke-LabADMXImport] Third-party ADMX bundle path not found: $bundlePath. Skipping."
                continue
            }

            # Count .admx files in bundle (validate it has content)
            $admxCount = @(Get-ChildItem -Path $bundlePath -Filter '*.admx' -Recurse -ErrorAction SilentlyContinue).Count
            if ($admxCount -eq 0) {
                Write-Warning "[Invoke-LabADMXImport] Third-party ADMX bundle contains no .admx files: $bundlePath. Skipping."
                continue
            }

            # Copy all ADMX/ADML files from bundle to Central Store
            try {
                # Copy ADMX files (root level)
                $bundleAdmxFiles = Get-ChildItem -Path $bundlePath -Filter '*.admx' -File -ErrorAction SilentlyContinue
                foreach ($file in $bundleAdmxFiles) {
                    $destPath = Join-Path $centralStorePath $file.Name
                    Copy-Item -Path $file.FullName -Destination $destPath -Force
                    $filesImported++
                }

                # Copy ADML subdirectories
                $bundleAdmlDirs = Get-ChildItem -Path $bundlePath -Directory -ErrorAction SilentlyContinue
                foreach ($dir in $bundleAdmlDirs) {
                    $destDir = Join-Path $centralStorePath $dir.Name
                    if (-not (Test-Path $destDir)) {
                        New-Item -ItemType Directory -Path $destDir -Force | Out-Null
                    }
                    $admlFiles = Get-ChildItem -Path $dir.FullName -Filter '*.adml' -File -ErrorAction SilentlyContinue
                    foreach ($file in $admlFiles) {
                        Copy-Item -Path $file.FullName -Destination $destDir -Force
                        $filesImported++
                    }
                }

                $thirdPartyBundles++
                Write-Verbose "[Invoke-LabADMXImport] Imported third-party bundle: $bundleName ($admxCount ADMX files)"
            }
            catch {
                Write-Warning "[Invoke-LabADMXImport] Failed to import third-party bundle $bundleName`: $($_.Exception.Message)"
            }
        }

        $success = $true
    }
    catch {
        $success = $false
        $message = $_.Exception.Message
        Write-Warning "[Invoke-LabADMXImport] Failed to populate ADMX Central Store: $message"
    }

    $duration = [int]((Get-Date) - $startTime).TotalSeconds

    return [pscustomobject]@{
        FilesImported          = $filesImported
        Success                = $success
        CentralStorePath       = $centralStorePath
        ThirdPartyBundlesProcessed = $thirdPartyBundles
        DurationSeconds        = $duration
        Message                = $message
    }
}
```

Key implementation details:
- Central Store path format: `\\domain\SYSVOL\domain\Policies\PolicyDefinitions`
- Copy operations run inside Invoke-Command on the DC (remote execution)
- Copy both .admx files (root) and ADML subdirectories (en-US, etc.)
- Third-party bundles: validate path exists, validate contains .admx files, then copy
- Each third-party bundle processed independently (failure on one doesn't block others)
- Returns result object matching Invoke-LabSTIGBaselineCore pattern (metrics + audit fields)
- Verbose logging for all operations

**Verify:**
- Function loads without error when dot-sourced
- Returns FilesImported > 0 when PolicyDefinitions has content
- Creates Central Store directory if it doesn't exist
- Processes ThirdPartyADMX array when config has entries
- Skips invalid third-party paths with warning but doesn't fail
- Returns Success=$false on exception with Message populated

**Done:**
Invoke-LabADMXImport.ps1 exists in Private/ with OS ADMX copy, third-party bundle support, and audit result object.

### Task 3: Create unit tests for Wait-LabADReady

**Type:** auto

**Files:**
- Tests/Wait-LabADReady.Tests.ps1

**Action:**
Create Tests/Wait-LabADReady.Tests.ps1 with these test cases:

1. **returns Ready=true when ADWS is immediately responsive**
   - Mock Get-ADDomain to return success immediately
   - Assert Ready = $true, WaitSeconds = 0

2. **returns Ready=false after timeout when domain never responds**
   - Mock Get-ADDomain to always throw
   - Set TimeoutSeconds = 30
   - Assert Ready = $false, WaitSeconds >= 30

3. **returns actual wait time when ADWS becomes ready mid-loop**
   - Mock Get-ADDomain to throw twice, then succeed
   - Set RetryIntervalSeconds = 5
   - Assert Ready = $true, WaitSeconds between 10-15

4. **passes DomainName correctly to Get-ADDomain**
   - Mock Get-ADDomain with parameter filter
   - Assert called with correct domain name

5. **respects custom TimeoutSeconds parameter**
   - Mock Get-ADDomain to always throw
   - Pass TimeoutSeconds = 60
   - Assert loop exits after ~60 seconds

6. **respects custom RetryIntervalSeconds parameter**
   - Mock Get-ADDomain to throw 3 times then succeed
   - Pass RetryIntervalSeconds = 2
   - Assert WaitSeconds approximately 6 (3 retries * 2s)

Use BeforeAll to dot-source the helper, and BeforeEach to mock Get-ADDomain. AfterEach to remove mocks.

**Verify:**
- `Invoke-Pester Tests/Wait-LabADReady.Tests.ps1` passes all 6 tests
- Get-ADDomain is mocked (no actual AD queries during test)
- Tests complete quickly (no real 120-second waits)

**Done:**
Wait-LabADReady.Tests.ps1 exists with 6 test cases covering success, timeout, retry logic, and parameter variations.

### Task 4: Create unit tests for Invoke-LabADMXImport

**Type:** auto

**Files:**
- Tests/LabADMXImport.Tests.ps1

**Action:**
Create Tests/LabADMXImport.Tests.ps1 with these test cases:

1. **returns FilesImported > 0 when PolicyDefinitions has ADMX files**
   - Mock Invoke-Command to return file count
   - Mock Get-LabADMXConfig for empty ThirdPartyADMX
   - Assert FilesImported > 0, Success = $true

2. **creates Central Store directory when it doesn't exist**
   - Mock Test-Path to return $false for Central Store
   - Mock New-Item for directory creation
   - Assert New-Item called once

3. **processes empty ThirdPartyADMX array without error**
   - Mock Invoke-Command for OS copy
   - Mock Get-LabADMXConfig to return ThirdPartyADMX = @()
   - Assert ThirdPartyBundlesProcessed = 0

4. **processes single third-party ADMX bundle successfully**
   - Mock Get-LabADMXConfig with one bundle entry
   - Mock Test-Path to return $true for bundle path
   - Mock Get-ChildItem for ADMX file discovery
   - Assert FilesImported includes bundle files, ThirdPartyBundlesProcessed = 1

5. **skips third-party bundle when path doesn't exist**
   - Mock Get-LabADMXConfig with one bundle entry
   - Mock Test-Path to return $false for bundle path
   - Assert warning logged, ThirdPartyBundlesProcessed = 0

6. **skips third-party bundle when no ADMX files found**
   - Mock Get-LabADMXConfig with one bundle entry
   - Mock Test-Path to return $true
   - Mock Get-ChildItem to return 0 ADMX files
   - Assert warning logged, ThirdPartyBundlesProcessed = 0

7. **continues processing after one third-party bundle fails**
   - Mock Get-LabADMXConfig with two bundle entries
   - First bundle: Mock Copy-Item to throw
   - Second bundle: Mock all successful
   - Assert ThirdPartyBundlesProcessed = 1, Success = $true

8. **returns Success=false on Central Store copy failure**
   - Mock Invoke-Command to throw exception
   - Assert Success = $false, Message populated

9. **returns accurate DurationSeconds**
   - Mock Invoke-Command for successful copy
   - Record start time before call, calculate expected duration
   - Assert DurationSeconds within reasonable range

10. **returns CentralStorePath in result object**
    - Mock Invoke-Command for successful copy
    - Assert CentralStorePath matches expected format

Use BeforeAll to dot-source helpers. Mock Get-LabADMXConfig, Invoke-Command, Test-Path, New-Item, Get-ChildItem, Copy-Item appropriately per test.

**Verify:**
- `Invoke-Pester Tests/LabADMXImport.Tests.ps1` passes all 10 tests
- All external dependencies mocked (no real DC access during test)
- Tests cover success path, third-party bundles, error handling

**Done:**
LabADMXImport.Tests.ps1 exists with 10 test cases covering OS ADMX copy, third-party bundles, and error handling.

## Verification

Run all tests for this plan:

```powershell
# Load helpers to verify syntax
. .\Private\Wait-LabADReady.ps1
. .\Private\Invoke-LabADMXImport.ps1

# Verify function parameters
Get-Command Wait-LabADReady | Select-Object -ExpandProperty Parameters
Get-Command Invoke-LabADMXImport | Select-Object -ExpandProperty Parameters

# Run unit tests
Invoke-Pester Tests/Wait-LabADReady.Tests.ps1
Invoke-Pester Tests/LabADMXImport.Tests.ps1
```

Expected results:
- Both helpers load without error
- Wait-LabADReady has parameters: DomainName (mandatory), TimeoutSeconds, RetryIntervalSeconds
- Invoke-LabADMXImport has parameters: DCName (mandatory), DomainName (mandatory)
- All 6 Wait-LabADReady tests pass
- All 10 Invoke-LabADMXImport tests pass

## Success Criteria

1. Wait-LabADReady gates on Get-ADDomain with configurable timeout and retry interval
2. Invoke-LabADMXImport copies OS ADMX/ADML to Central Store via remote Invoke-Command
3. Third-party ADMX bundles processed from config paths with validation and error isolation
4. Result objects follow Invoke-LabSTIGBaselineCore pattern (Success + metrics + duration)
5. All 16 unit tests pass with full dependency mocking

## Output

- Private/Wait-LabADReady.ps1 created
- Private/Invoke-LabADMXImport.ps1 created
- Tests/Wait-LabADReady.Tests.ps1 created with 6 passing tests
- Tests/LabADMXImport.Tests.ps1 created with 10 passing tests
